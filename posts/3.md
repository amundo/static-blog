---
title: Static Site Generator - Adding Index Page Generation
date: 2025-02-17
description: Adding an automatically generated index page with efficient updates
---

In this third stage of development, we've added index page generation to our static site generator. This creates a home page that lists all blog posts, sorted by date, with their titles and descriptions. We've implemented this in a way that maintains the efficiency of our file watching system.

## New Feature: Index Page Generation

The generator now:
- Creates an index.html in the root of the blog directory
- Lists all posts in reverse chronological order
- Displays post metadata (title, date, description)
- Updates efficiently when files change
- Maintains the same responsive styling as individual posts

### Implementation Changes

The main changes involve maintaining post metadata in memory and generating an index page efficiently. Here's the new functionality we've added:

```js
// Keep track of post metadata
const postMetadata = new Map();

// Generate index page HTML
function generateIndexPage(posts) {
  const postsList = posts
    .sort((a, b) => b.date - a.date)
    .map(post => `
      <article class="post-preview">
        <h2><a href="${post.slug}.html">${post.title}</a></h2>
        <time>${post.date.toLocaleDateString()}</time>
        ${post.description ? `<p>${post.description}</p>` : ''}
      </article>
    `).join('\n');

  return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blog Index</title>
    <style>
      body {
        max-width: 800px;
        margin: 0 auto;
        padding: 1rem;
        font-family: system-ui, sans-serif;
        line-height: 1.5;
      }
      .post-preview {
        margin-bottom: 2rem;
        padding-bottom: 2rem;
        border-bottom: 1px solid #eee;
      }
      .post-preview:last-child {
        border-bottom: none;
      }
      h2 {
        margin: 0;
      }
      time {
        color: #666;
        font-size: 0.9rem;
      }
      a {
        color: #0066cc;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
    </style>
</head>
<body>
    <h1>Blog Posts</h1>
    <main>
      ${postsList}
    </main>
</body>
</html>
  `;
}

// Modified build function to maintain metadata state
async function build(postsDir = './posts', outputDir = './blog') {
  try {
    await ensureDir(outputDir);
    
    // Clear existing metadata
    postMetadata.clear();
    
    for await (const entry of Deno.readDir(postsDir)) {
      if (entry.isFile && entry.name.endsWith('.md')) {
        const content = await Deno.readTextFile(join(postsDir, entry.name));
        const { attrs: metadata } = extract(content);
        const slug = entry.name.split('.')[0];
        
        postMetadata.set(slug, {
          title: metadata.title,
          date: new Date(metadata.date),
          description: metadata.description,
          slug
        });
        
        await processFile(join(postsDir, entry.name), outputDir);
      }
    }
    
    // Generate and write index page
    const indexHtml = generateIndexPage([...postMetadata.values()]);
    await Deno.writeTextFile(join(outputDir, 'index.html'), indexHtml);
    console.log('Generated index.html');
  } catch (error) {
    console.error('Build failed:', error);
  }
}

// Enhanced watch mode for efficient updates
async function watch(postsDir = './posts', outputDir = './blog') {
  console.log('Watching for changes...');
  
  // Initial build and metadata collection
  await build(postsDir, outputDir);
  
  const watcher = Deno.watchFs(postsDir);
  
  for await (const event of watcher) {
    if (event.kind === 'modify' || event.kind === 'create') {
      for (const path of event.paths) {
        if (path.endsWith('.md')) {
          try {
            // Process the changed file
            await processFile(path, outputDir);
            
            // Update metadata for this post
            const content = await Deno.readTextFile(path);
            const { attrs: metadata } = extract(content);
            const fileName = path.split('/').pop();
            const slug = fileName?.split('.')[0];
            
            postMetadata.set(slug, {
              title: metadata.title,
              date: new Date(metadata.date),
              description: metadata.description,
              slug
            });
            
            // Regenerate index with updated metadata
            const indexHtml = generateIndexPage([...postMetadata.values()]);
            await Deno.writeTextFile(join(outputDir, 'index.html'), indexHtml);
            console.log('Updated index.html');
          } catch (error) {
            console.error(`Error processing ${path}:`, error);
          }
        }
      }
    }
  }
}
```

### How It Works

1. **Metadata Management**:
   - We maintain a Map of post metadata in memory
   - Each post's metadata is keyed by its slug
   - The Map is populated during initial build
   - Individual entries are updated when files change

2. **Efficient Updates**:
   - When a file changes, we only process that specific file
   - The metadata Map is updated for the changed file
   - The index page is regenerated using the current state
   - No need to reprocess unchanged files

3. **Index Generation**:
   - Posts are sorted by date (newest first)
   - Each post is rendered as a preview article
   - Links are created using the file slug
   - The page maintains consistent styling with post pages

## Example Usage

Your markdown files should include metadata in the frontmatter:

```markdown
---
title: My New Post
date: 2025-02-17
description: A brief summary of what this post is about
---

Post content goes here...
```

The index.html will be automatically generated and updated whenever files change.

## Technical Details

### Performance Considerations

- Metadata is cached in memory to avoid unnecessary file reads
- Only changed files are processed during watch mode
- Index updates happen independently of file processing
- The watch mode maintains Deno's efficient file system monitoring

### Styling and Structure

- Semantic HTML with article tags for posts
- Consistent styling with individual post pages
- Responsive design that works on all devices
- Clear visual hierarchy and post separation

## Next Steps

With efficient index generation implemented, our next planned features are:
- Tag support with tag-based filtering
- Syntax highlighting for code blocks
- Cache invalidation for faster builds
- RSS feed generation

## Requirements

The requirements remain the same as previous stages:
- Deno 1.41 or later
- Write permissions for the output directory
- Read permissions for the posts directory
- npm package: marked

The addition of efficient index page generation makes the static site generator more complete and performant, providing a proper entry point for blog readers while maintaining fast rebuild times during development.