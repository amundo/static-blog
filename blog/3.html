
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Static Site Generator - Adding Index Page Generation</title>
    <style>
      body {
        max-width: 800px;
        margin: 0 auto;
        padding: 1rem;
        font-family: system-ui, sans-serif;
        line-height: 1.5;
      }
      pre {
        padding: 1rem;
        background: #f6f8fa;
        border-radius: 4px;
        overflow-x: auto;
      }
      a {
        color: #0066cc;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
    </style>
</head>
<body>
    <article>
        <h1>Static Site Generator - Adding Index Page Generation</h1>
        <time>2/16/2025</time>
        <p>In this third stage of development, we&#39;ve added index page generation to our static site generator. This creates a home page that lists all blog posts, sorted by date, with their titles and descriptions. We&#39;ve implemented this in a way that maintains the efficiency of our file watching system.</p>
<h2>New Feature: Index Page Generation</h2>
<p>The generator now:</p>
<ul>
<li>Creates an index.html in the root of the blog directory</li>
<li>Lists all posts in reverse chronological order</li>
<li>Displays post metadata (title, date, description)</li>
<li>Updates efficiently when files change</li>
<li>Maintains the same responsive styling as individual posts</li>
</ul>
<h3>Implementation Changes</h3>
<p>The main changes involve maintaining post metadata in memory and generating an index page efficiently. Here&#39;s the new functionality we&#39;ve added:</p>
<pre><code class="language-js">// Keep track of post metadata
const postMetadata = new Map();

// Generate index page HTML
function generateIndexPage(posts) {
  const postsList = posts
    .sort((a, b) =&gt; b.date - a.date)
    .map(post =&gt; `
      &lt;article class=&quot;post-preview&quot;&gt;
        &lt;h2&gt;&lt;a href=&quot;${post.slug}.html&quot;&gt;${post.title}&lt;/a&gt;&lt;/h2&gt;
        &lt;time&gt;${post.date.toLocaleDateString()}&lt;/time&gt;
        ${post.description ? `&lt;p&gt;${post.description}&lt;/p&gt;` : &#39;&#39;}
      &lt;/article&gt;
    `).join(&#39;\n&#39;);

  return `
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Blog Index&lt;/title&gt;
    &lt;style&gt;
      body {
        max-width: 800px;
        margin: 0 auto;
        padding: 1rem;
        font-family: system-ui, sans-serif;
        line-height: 1.5;
      }
      .post-preview {
        margin-bottom: 2rem;
        padding-bottom: 2rem;
        border-bottom: 1px solid #eee;
      }
      .post-preview:last-child {
        border-bottom: none;
      }
      h2 {
        margin: 0;
      }
      time {
        color: #666;
        font-size: 0.9rem;
      }
      a {
        color: #0066cc;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Blog Posts&lt;/h1&gt;
    &lt;main&gt;
      ${postsList}
    &lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;
  `;
}

// Modified build function to maintain metadata state
async function build(postsDir = &#39;./posts&#39;, outputDir = &#39;./blog&#39;) {
  try {
    await ensureDir(outputDir);
    
    // Clear existing metadata
    postMetadata.clear();
    
    for await (const entry of Deno.readDir(postsDir)) {
      if (entry.isFile &amp;&amp; entry.name.endsWith(&#39;.md&#39;)) {
        const content = await Deno.readTextFile(join(postsDir, entry.name));
        const { attrs: metadata } = extract(content);
        const slug = entry.name.split(&#39;.&#39;)[0];
        
        postMetadata.set(slug, {
          title: metadata.title,
          date: new Date(metadata.date),
          description: metadata.description,
          slug
        });
        
        await processFile(join(postsDir, entry.name), outputDir);
      }
    }
    
    // Generate and write index page
    const indexHtml = generateIndexPage([...postMetadata.values()]);
    await Deno.writeTextFile(join(outputDir, &#39;index.html&#39;), indexHtml);
    console.log(&#39;Generated index.html&#39;);
  } catch (error) {
    console.error(&#39;Build failed:&#39;, error);
  }
}

// Enhanced watch mode for efficient updates
async function watch(postsDir = &#39;./posts&#39;, outputDir = &#39;./blog&#39;) {
  console.log(&#39;Watching for changes...&#39;);
  
  // Initial build and metadata collection
  await build(postsDir, outputDir);
  
  const watcher = Deno.watchFs(postsDir);
  
  for await (const event of watcher) {
    if (event.kind === &#39;modify&#39; || event.kind === &#39;create&#39;) {
      for (const path of event.paths) {
        if (path.endsWith(&#39;.md&#39;)) {
          try {
            // Process the changed file
            await processFile(path, outputDir);
            
            // Update metadata for this post
            const content = await Deno.readTextFile(path);
            const { attrs: metadata } = extract(content);
            const fileName = path.split(&#39;/&#39;).pop();
            const slug = fileName?.split(&#39;.&#39;)[0];
            
            postMetadata.set(slug, {
              title: metadata.title,
              date: new Date(metadata.date),
              description: metadata.description,
              slug
            });
            
            // Regenerate index with updated metadata
            const indexHtml = generateIndexPage([...postMetadata.values()]);
            await Deno.writeTextFile(join(outputDir, &#39;index.html&#39;), indexHtml);
            console.log(&#39;Updated index.html&#39;);
          } catch (error) {
            console.error(`Error processing ${path}:`, error);
          }
        }
      }
    }
  }
}
</code></pre>
<h3>How It Works</h3>
<ol>
<li><p><strong>Metadata Management</strong>:</p>
<ul>
<li>We maintain a Map of post metadata in memory</li>
<li>Each post&#39;s metadata is keyed by its slug</li>
<li>The Map is populated during initial build</li>
<li>Individual entries are updated when files change</li>
</ul>
</li>
<li><p><strong>Efficient Updates</strong>:</p>
<ul>
<li>When a file changes, we only process that specific file</li>
<li>The metadata Map is updated for the changed file</li>
<li>The index page is regenerated using the current state</li>
<li>No need to reprocess unchanged files</li>
</ul>
</li>
<li><p><strong>Index Generation</strong>:</p>
<ul>
<li>Posts are sorted by date (newest first)</li>
<li>Each post is rendered as a preview article</li>
<li>Links are created using the file slug</li>
<li>The page maintains consistent styling with post pages</li>
</ul>
</li>
</ol>
<h2>Example Usage</h2>
<p>Your markdown files should include metadata in the frontmatter:</p>
<pre><code class="language-markdown">---
title: My New Post
date: 2025-02-17
description: A brief summary of what this post is about
---

Post content goes here...
</code></pre>
<p>The index.html will be automatically generated and updated whenever files change.</p>
<h2>Technical Details</h2>
<h3>Performance Considerations</h3>
<ul>
<li>Metadata is cached in memory to avoid unnecessary file reads</li>
<li>Only changed files are processed during watch mode</li>
<li>Index updates happen independently of file processing</li>
<li>The watch mode maintains Deno&#39;s efficient file system monitoring</li>
</ul>
<h3>Styling and Structure</h3>
<ul>
<li>Semantic HTML with article tags for posts</li>
<li>Consistent styling with individual post pages</li>
<li>Responsive design that works on all devices</li>
<li>Clear visual hierarchy and post separation</li>
</ul>
<h2>Next Steps</h2>
<p>With efficient index generation implemented, our next planned features are:</p>
<ul>
<li>Tag support with tag-based filtering</li>
<li>Syntax highlighting for code blocks</li>
<li>Cache invalidation for faster builds</li>
<li>RSS feed generation</li>
</ul>
<h2>Requirements</h2>
<p>The requirements remain the same as previous stages:</p>
<ul>
<li>Deno 1.41 or later</li>
<li>Write permissions for the output directory</li>
<li>Read permissions for the posts directory</li>
<li>npm package: marked</li>
</ul>
<p>The addition of efficient index page generation makes the static site generator more complete and performant, providing a proper entry point for blog readers while maintaining fast rebuild times during development.</p>

    </article>
</body>
</html>
  