<!doctype html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Static Site Generator - Stage 1</title>
    <style>
      body {
        max-width: 800px;
        margin: 0 auto;
        padding: 1rem;
        font-family: system-ui, sans-serif;
        line-height: 1.5;
      }
      pre {
        padding: 1rem;
        background: #f6f8fa;
        border-radius: 4px;
        overflow-x: auto;
      }
    </style>
  </head>
  <body>
    <article>
      <nav>
        <a href="index.html" class="home-link">Home</a>
        <span class="previous-post"></span>
        <span class="next-post"><a href="2.html">Static Site Generator - Adding Watch Mode - Stage 2 →</a></span>
      </nav>

      <header>
        <h1 class="post-title">Static Site Generator - Stage 1</h1>
        <h2 class="post-author"></h2>
        <time class="post-date"></time>
        <div class="post-tags"></div>
        <div class="post-description">Documentation of the initial version of our Deno-based static site generator</div>
      </header>

      <main class="post-content"><p>This is the initial version of our static site generator built with Deno. It
provides basic functionality for converting markdown files with YAML frontmatter
into HTML pages.</p>
<h2>Features</h2>
<ul>
<li>Converts markdown files to HTML using marked</li>
<li>Supports YAML frontmatter for metadata</li>
<li>Basic responsive styling</li>
<li>Simple directory structure</li>
</ul>
<h2>Usage</h2>
<h3>Directory Structure</h3>
<pre><code>your-project/
  ├── posts/            # Your markdown files go here
  │   └── post-1.md
  ├── blog/             # Generated HTML files appear here
  └── generate.js      # The static site generator script
</code></pre>
<h3>Markdown Format</h3>
<p>Your markdown files should include YAML frontmatter at the top:</p>
<pre><code class="language-markdown">---
title: Your Post Title
date: 2025-02-17
---

Your markdown content goes here...
</code></pre>
<h3>Running the Generator</h3>
<pre><code class="language-bash">deno run --allow-read --allow-write --unstable-temporal generator.js
</code></pre>
<h2>How It Works</h2>
<p>The generator is built using modern JavaScript and Deno. Here's the complete
code with explanations:</p>
<pre><code class="language-js">import { basename, join, dirname } from "@std/path"
import { ensureDir, expandGlob } from "@std/fs"
import { extract } from "@std/front-matter/any"
import { parse } from "@marked"
import { renderTemplate } from "./render-template.js"

/**
 * Build a static site from markdown files
 * 
 * @param {Object} options Build options
 * @param {String} options.postsDirectory Directory containing markdown files
 * @param {String} options.outputDirectory Directory to write generated files
 * @param {String} options.templateDirectory Directory containing HTML templates
 * @returns {Object} Build results
 */
const build = async ({ 
  postsDirectory = 'posts', 
  outputDirectory = 'blog',
  templateDirectory = 'templates'
} = {}) =&gt; {
  // Store original relative paths before resolving
  const originalOutputDir = outputDirectory
  
  
  // Ensure directories exist
  await ensureDir(postsDirectory)
  await ensureDir(outputDirectory)
  await ensureDir(templateDirectory)
  
  // Read templates
  const postTemplatePath = join(templateDirectory, "post-template.html")
  const indexTemplatePath = join(templateDirectory, "index-template.html")
  const postTemplate = await Deno.readTextFile(postTemplatePath)
  const indexTemplate = await Deno.readTextFile(indexTemplatePath)
  
  // Find all markdown files
  const globPattern = `${postsDirectory}/*.md`
  const postFileEntries = await Array.fromAsync(expandGlob(globPattern))
  
  // Process all posts
  const posts = []
  
  for (const postFileEntry of postFileEntries) {
    // Read and parse markdown
    const postMarkdown = await Deno.readTextFile(postFileEntry.path)
    const { attrs: metadata, body: markdown } = extract(postMarkdown)
    
    // Generate HTML from markdown
    const html = parse(markdown)
    
    // Prepare filename info
    const fileName = basename(postFileEntry.path, ".md")
    const outputFileName = `${fileName}.html`
    const outputPath = join(outputDirectory, outputFileName)
    
    // Normalize date if present
    if (metadata.date &amp;&amp; typeof metadata.date === 'string') {
      try {
        // Ensure consistent date format
        const date = new Date(metadata.date)
        metadata.isoDate = date.toISOString()
        metadata.formattedDate = date.toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        })
      } catch (e) {
        console.warn(`Invalid date format in ${fileName}: ${metadata.date}`)
      }
    }
    
    // Add file paths to metadata
    Object.assign(metadata, {
      markdownPath: postFileEntry.path,
      outputPath,
      // Create URL relative to the project structure
      url: `${outputFileName}`,
    })
    
    // Store post information
    posts.push({
      metadata,
      markdown,
      html,
    })
  }
  
  // Sort posts by date (newest first)
  posts.sort((a, b) =&gt; {
    // Use isoDate if available, otherwise fallback to comparison
    const dateA = a.metadata.isoDate ? new Date(a.metadata.isoDate) : new Date(0)
    const dateB = b.metadata.isoDate ? new Date(b.metadata.isoDate) : new Date(0)
    return dateB - dateA
  })
  
  // Add navigation links
  posts.forEach((post, index) =&gt; {
    post.metadata.isFirst = index === 0
    post.metadata.isLast = index === posts.length - 1
    post.metadata.previousPost = index &gt; 0 ? posts[index - 1].metadata : null
    post.metadata.nextPost = index &lt; posts.length - 1 ? posts[index + 1].metadata : null
  })

  // Generate post files
  for (const post of posts) {
    const { metadata, html } = post
    
    // Render the post using template
    const renderedPost = `&lt;!doctype html&gt;\n` + renderTemplate(postTemplate, {
      'title': metadata.title || 'Untitled Post',
      '.post-date': metadata.formattedDate || '',
      'main': html,
      '.post-title': metadata.title || 'Untitled Post',
      '.post-description': metadata.description || '',
      '.post-author': metadata.author || '',
      '.post-tags': metadata.tags ? metadata.tags.join(', ') : '',
      
      // Navigation
      '.previous-post': metadata.previousPost ? 
        `&lt;a href="${metadata.previousPost.url}"&gt;&amp;larr; ${metadata.previousPost.title}&lt;/a&gt;` : '',
      '.next-post': metadata.nextPost ? 
        `&lt;a href="${metadata.nextPost.url}"&gt;${metadata.nextPost.title} &amp;rarr;&lt;/a&gt;` : '',
    })
    
    // Write post file
    await ensureDir(dirname(metadata.outputPath))
    await Deno.writeTextFile(metadata.outputPath, renderedPost)
  }
  
  // Extract metadata for index
  const postMetadata = posts.map(post =&gt; post.metadata)
  
  // Build index page
  const indexHtml = renderTemplate(indexTemplate, {
    '.post-list': buildPostList(postMetadata),
    'title': 'Blog Index',
    '.blog-title': 'My Blog',
    '.blog-description': 'A collection of my thoughts and ideas',
  })
  
  // Write index file
  const indexOutputPath = join(outputDirectory, "index.html")
  await Deno.writeTextFile(indexOutputPath, indexHtml)
  console.log(`Generated: ${indexOutputPath}`)
  
  console.log(`Build complete: ${posts.length} posts generated`)
  return { posts: postMetadata }
}

/**
 * Generate HTML for the post list
 * 
 * @param {Array} posts List of post metadata objects
 * @returns {String} HTML for the post list
 */
function buildPostList(posts) {
  return posts.map(post =&gt; {
    return `
      &lt;article class="post-item"&gt;
        &lt;header&gt;
          &lt;h2&gt;&lt;a href="${post.url}"&gt;${post.title || 'Untitled Post'}&lt;/a&gt;&lt;/h2&gt;
          ${post.formattedDate ? `&lt;time datetime="${post.isoDate}"&gt;${post.formattedDate}&lt;/time&gt;` : ''}
        &lt;/header&gt;
        ${post.description ? `&lt;p&gt;${post.description}&lt;/p&gt;` : ''}
        ${post.tags ? `&lt;div class="tags"&gt;${post.tags.map(tag =&gt; 
          `&lt;span class="tag"&gt;${tag}&lt;/span&gt;`).join('')}&lt;/div&gt;` : ''}
      &lt;/article&gt;
    `
  }).join('\n')
}

// Run build if executed directly
if (import.meta.main) {
  await build()
}

export { build }
</code></pre>
<h3>Code Breakdown</h3>
<ol>
<li><p><strong>Imports</strong>:</p>
<ul>
<li><code>@std/path</code>: For path manipulation</li>
<li><code>@std/fs</code>: For file system operations</li>
<li><code>@std/front_matter/any</code>: For parsing YAML frontmatter</li>
<li><code>@marked</code>: For converting markdown to HTML (from npm)</li>
</ul>
</li>
<li><p><strong>HTML Generation</strong>:</p>
<ul>
<li>The <code>generatePage</code> function creates a complete HTML page</li>
<li>Includes responsive styling with system fonts</li>
<li>Centers content with max-width for readability</li>
<li>Styles code blocks with a light gray background</li>
</ul>
</li>
<li><p><strong>File Processing</strong>:</p>
<ul>
<li><code>processFile</code> handles individual markdown files</li>
<li>Extracts frontmatter metadata</li>
<li>Converts markdown to HTML using marked</li>
<li>Writes the final HTML file</li>
</ul>
</li>
<li><p><strong>Build Process</strong>:</p>
<ul>
<li>Creates the output directory if it doesn't exist</li>
<li>Finds all markdown files in the posts directory</li>
<li>Processes files concurrently using <code>Promise.all</code></li>
</ul>
</li>
</ol>
<h2>Next Steps</h2>
<p>Future enhancements planned:</p>
<ul>
<li>Index page generation</li>
<li>File watching for development</li>
<li>Tag support</li>
<li>Syntax highlighting</li>
<li>Cache invalidation for faster builds</li>
</ul>
<h2>Requirements</h2>
<ul>
<li>Deno 1.41 or later</li>
<li>Write permissions for the output directory</li>
<li>Read permissions for the posts directory</li>
<li>npm package: marked</li>
</ul>
</main>

      <footer></footer>
    </article>
  

</body></html>